# TCP和UDP

TCP和UDP都属于传输层协议，

### TCP
特点
1. 面向连接
2. 可靠传输
3. 面向字节流
4. 资源开销大


### UDP
特点：
1. 面向无连接
2. 不可靠传输
3. 面向数据报
4. 延迟低

### TCP的传输过程

发送：
1. 应用层将数据给到传输层(TCP协议)
2. 传输层的TCP协议对总数据进行分段，每一个数据段包含[TCP头+有效数据]，TCP头包含(端口号，校验和等)，(其中分段大小MSS(最大分段单元)通过三次握手确定)
3. 传输层将数据交给网络层(IP协议)
4. 网络层对数据进行分片，分片大小通过MTU确定，添加网络层头部[ip头部 + 上一层数据]，形成数据报，IP头部包含：源IP地址，目标IP地址
5. 数据链路层对数据成帧，按帧传输，会添加以太网头部，[以太网头部 + 上一层数据 + 校验尾部]，（如果校验出错，可能直接丢弃，也可能根据协议自己做重传，数据链路层也有自己的重传协议）（以太网头部，就是下一跳的mac地址）（数据链路层一般不会继续分帧了，所以叫成帧）
6. 物理层，将bit进行光电信号的传输

接收：只有在目标主机的才会对数据进行组装，数据链路层中只进行数据帧的转发
1. 数据链路层将数据帧转化为数据报，交给网络层
2. 网络层对数据报进行组装，形成数据段，交给传输层
3. 传输层对数据段进行组装，形成字节流，装入内核缓存区中，通过应用层的``recv()``进行读取

### UDP的传输过程

与TCP的区别在于，UDP层对应用层的数据，只进行UDP头部的添加，不会进行分段，如果超出MTU，则有IP层进行数据分片（不分段可以保持发送边界的完整）
同理，也由IP层进行数据组装

### TCP特点

> 1. 有序，先发先到（应用层感知）
> 2. 可靠，可靠交付（应用层感知）

### TCP头部信息

至少20字节

<img width="366" height="200" alt="image" src="https://github.com/user-attachments/assets/25436d50-43b7-4237-8c99-7cac18a3f392" />

### UDP头部信息

固定8字节

<img width="344" height="103" alt="image" src="https://github.com/user-attachments/assets/5ffb0aee-04c3-49ac-b38c-c3938372385d" />

### 问题一：TCP如何保证可靠传输

1. 首部校验和
2. 确认应答机制
3. 超时重传机制
4. 流量控制
5. 拥塞控制


### 问题二：如何使用UDP实现可靠传输

如同QUIC协议，在应用层实现可靠传输

因为传输层的TPC/UDP协议已经被广泛的使用，除非进行大面积的升级

### 问题三：队头阻塞是如何解决的?

> 待补充

### 问题四：TCP面向字节流和UDP面向数据报的区别是什么？

> - TCP面向字节流就是，在TCP层对应用层的数据进行了分段，所以在目标传输层进行数据组装时，是无法区分出是否是完整的数据报的，只是对数据报进行乱序重排，放入缓冲区，所以TCP只能看到字节流
> - UDP没有在传输层进行分段，(过大可以在网络层分段)，所以网络层交给传输层是一个完整的数据报，其中就是应用层的完整信息


### 问题五：为什么UDP延迟低？

### 问题六：TCP和UDP哪个包体积小？

> TCP的有效体积更小，因为在相同MTU下，TCP报头信息更大(约20字节)，所以一个TCP数据包的传输数据更少，所以体积更小

### 问题九：TCP粘包是什么？

> 由于TCP层是面向字节流的，所以将数据交付给应用层时，无法区分有效的发送边界
> HTTP协议层做了处理，所以web前端开发无感知粘包

### 问题十：TCP粘包怎么解决？

添加应用层协议，例如：
> 1. 规定数据使用特定的分隔符，进行数据划分
> 2. 规定数据的开头字节，用来表示数据的长度，每次先读取数据长度，再按长度读取数据

### 问题十一：UDP为什么没有粘包？

> UDP没有在UDP层分段

### 问题十二：路由器是怎么进行路由的？

> 路由表，维护目标IP地址到下一跳IP地址的映射
> 通过RIP协议更新

### 问题十三：数据链路层是怎么进行帧传输的？

> 维护目标IP地址，到MAC地址的映射
> 通过ARP协议更新

