# 236. 二叉树的最近公共祖先

### 初次提交
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // 后序遍历，记录两个节点的祖先，求交集
        if (!root) {
            return nullptr;
        }
        vector<TreeNode*> sk;
        sk.push_back(root);
        unordered_set<TreeNode*> set;
        TreeNode* lastNode = nullptr;
        while (!sk.empty()) {
            TreeNode* node = sk.back();
            if (node->left && lastNode == node->left && node->right) {
                sk.push_back(node->right);
            } else if (node->right && !node->left && lastNode != node->right) {
                sk.push_back(node->right);
            } else if (node->right && lastNode == node->right) {
                lastNode = node;
            } else if (!node->right && lastNode == node->left) {
                lastNode = node;
            } else if (!node->left && !node->right) {
                lastNode = node;
            } else if (node->left && lastNode != node->left) {
                sk.push_back(node->left);
            }
            if (node == lastNode) {
                if ((node == p || node == q) && !set.empty()) {
                    // 结束
                    for (auto it = sk.rbegin(); it != sk.rend(); it ++) {
                        auto target = set.find(*it);
                        if (target != set.end()) {
                            return *target;
                        }
                    }
                    return nullptr;
                }
                if (node == p || node == q) {
                    // sk存储至set
                    for (TreeNode* n : sk) {
                        set.insert(n);
                    }
                }
                sk.pop_back();
            }
            
        }
        return nullptr;
    }
};
```
### 结果
![image](https://github.com/user-attachments/assets/cfdc3e36-8418-45b0-9f33-b12f142e3392)

### 分析
时间复杂度O(n)，空间复杂度O(n)

### 优化
将简化后序遍历代码

### 二次提交
```
```

