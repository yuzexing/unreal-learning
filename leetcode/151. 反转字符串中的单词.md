# 151. 反转字符串中的单词

### 初次提交
```
class Solution {
public:
    string reverseWords(string s) {
        std::stack<std::string_view> sk;
        std::string_view sv(s.c_str());
        int i = 0;
        int j = 0;
        while (j < s.size()) {
            while (s[i] == ' ' && i < s.size()) {
                i++;
            }
            if (sv[j] == ' ' && i < j) {
                std::string_view sv_temp = sv.substr(i, j - i);
                sk.push(sv_temp);
                j++;
                i = j;
            }
            else {
                j++;
            }
        }
        if (i < j) {
            std::string_view sv_temp = sv.substr(i, j - i);
            sk.push(sv_temp);
        }
        string res;
        res.reserve(s.size());
        while (!sk.empty()) {
            string_view sv_temp = sk.top();
            res += sv_temp;
            sk.pop();
            if (!sk.empty()) {
                res += ' ';
            }
        }
        return res;
    }
};
```
### 结果

<img width="854" height="673" alt="image" src="https://github.com/user-attachments/assets/d447d547-e435-4889-abeb-30853ac7fd5d" />


### 分析

时间复杂度O(n)，空间复杂度O(n)

### 优化

考虑就地操作

### 二次提交
```
class Solution {
public:
    string reverseWords(string s) {
        // 先将字符串反转，再考虑将其中单词反转
        // 注意：需要将空格合并为一个
        int i = 0;
        int j = s.size() - 1;
        while (i <= j) {
            swap(s[i], s[j]);
            i++;
            j--;
        }
        i = 0; // 指向单词的头
        j = 0; // 指向单词的尾
        int k = 0; // 指向字符串有效位的后一位
        while (i < s.size() || j < s.size()) {
            // i首先定位非空格的单词开头
            // j在i之后找到单词结尾
            // k始终指向s有效位后一位
            while (i < s.size() && s[i] == ' ') {
                i++;
            }
            j = i;
            if (i >= s.size()) {
                break;
            }
            while (j + 1 < s.size() && s[j + 1] != ' ') {
                j++;
            }
            k = j + 1;
            while (i <= j) {
                swap(s[i], s[j]);
                j--;
                i++;
            }
            i = k;
            j = k;
        }
        i = 0;
        j = 0;
        while (j < s.size() && s[j] == ' ') {
            j++;
        }
        while (j < s.size()) {
            if (s[j] != ' ') {
                swap(s[i], s[j]);
                i++;
                j++;
            }
            else {
                swap(s[i], s[j]);
                i++;
                j++;
                while (j < s.size() && s[j] == ' ') {
                    j++;
                }
            }
        }
        if (s[i - 1] == ' ') {
            i--;
        }
        s.resize(i);
        return s;
    }
};
```
### 结果
<img width="476" height="382" alt="image" src="https://github.com/user-attachments/assets/961db310-cbe2-4fb7-9e69-45b6b2e334ac" />

### 分析
时间复杂度O(n)，空间复杂度O(1)


