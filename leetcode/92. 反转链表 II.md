# 92. 反转链表 II

### 初次提交
```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        vector<ListNode*> v;
        int i = 1;
        ListNode* p = head;
        ListNode* pre = nullptr;
        ListNode* tempRear = nullptr;
        ListNode* tempHead = nullptr;
        while (p && i <= right) {
            if (i == left - 1) {
                tempRear = p;
            } else if (i == right) {
                tempHead = p->next;
            }
            if (i >= left) {
                if (pre) {
                    pre->next = nullptr;
                }
                v.push_back(p);
                pre = p;
            }
            p = p->next;
            i ++;
        }
        if (tempRear) {
            for (int i = v.size() - 1; i >= 0; i --) {
                tempRear->next = v[i];
                tempRear = tempRear->next;
            }
            tempRear->next = tempHead;
            return head;
        }
        head = v.back();
        for (int i = v.size() - 1; i >= 1; i --) {
            v[i]->next = v[i - 1];
        }
        v[0]->next = tempHead;

        return head;
    }
};
```
### 结果
<img width="872" height="747" alt="image" src="https://github.com/user-attachments/assets/159d6eef-c805-48fd-94a6-c7b63e810510" />

### 分析

时间复杂度O(n)，空间复杂度O(n)

### 优化

考虑将减少空间复杂度

### 二次提交
```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        vector<ListNode*> v;
        int i = 1;
        ListNode* p = head;
        ListNode* pre = nullptr;
        ListNode* tempRear = nullptr; // 原链表第一个表尾
        ListNode* tempHead = nullptr; // 原链表的最后一个表头
        ListNode* sectionHead = nullptr;
        ListNode* sectionRear = nullptr;
        while (p && i <= right) {
            if (i == left - 1) {
                tempRear = p;
            }
            if (i == right) {
                tempHead = p->next;
                sectionRear = p;
            } 
            if (i == left) {
                sectionHead = p;
            }
            if (i >= left) {
                ListNode* temp = p->next;
                p->next = pre;
                pre = p;
                p = temp;
            } else {
                p = p->next;
            }
            i ++;
        }
        if (sectionHead) {
            sectionHead->next = tempHead;
        }
        if (tempRear) {
            tempRear->next = sectionRear;
            return head;
        }
        return sectionRear;
    }
};
```
### 结果
<img width="885" height="743" alt="image" src="https://github.com/user-attachments/assets/42fc7356-b887-4804-b15d-def67a2f7f2e" />

### 分析

时间复杂度O(n)，空间复杂度O(1)

