# 162. 寻找峰值

爬坡法有点难想到啊

### 初次提交
```
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        // 条件：nums[i-1] != nums[i] != nums[i + 1]
        // 二分爬坡查找：
        // 算法思想：永远向上坡走
        int i = 0;
        int j = nums.size() - 1;
        while(i <= j) {
            int mid = (i + j) >> 1;
            if (mid - 1 < 0) {
                if (mid + 1 >= nums.size()) {
                    return mid;
                }
                if (nums[mid] > nums[mid + 1]) {
                    return mid;
                }
                i = mid + 1;
            } else if (mid + 1 >= nums.size()) {
                if (nums[mid] > nums[mid - 1]) {
                    return mid;
                }
                j = mid - 1;
            } else {
                int leftValue = nums[mid - 1];
                int midValue = nums[mid];
                int rightValue = nums[mid + 1];
                if (midValue > leftValue && midValue > rightValue) {
                    return mid;
                }
                if (midValue > leftValue && midValue < rightValue) {
                    i = mid + 1;
                } else if (midValue < leftValue && midValue > rightValue) {
                    j = mid - 1;
                } else if (leftValue > midValue && rightValue > midValue) {
                    j = mid - 1; // 任选一条
                }
            }
        }
        return -1;

    }
};
```

### 结果
<img width="866" height="695" alt="image" src="https://github.com/user-attachments/assets/b578a654-89a8-4432-80ca-758ba2c1aedd" />

### 分析

时间复杂度O(logn)，空间复杂度O(1)

