# 76. 最小覆盖子串

### 初次提交
```
class Solution {
public:
    string minWindow(string s, string t) {
        int i = 0;
        unordered_map<char, int> remain; // 未加载
        unordered_map<char, int> reserve; // 已加载
        unordered_map<char, int> all; // 已加载
        for (char c : t) {
            remain[c] += 1;
            all[c] += 1;
        }
        int minLen = INT_MAX;
        string res;
        for (int j = 0; j < s.size(); j++) {
            // 首指针移动
            if (all.count(s[j]) > 0) {
                remain[s[j]] -= 1;
                reserve[s[j]] += 1;
                if (remain[s[j]] <= 0) {
                    remain.erase(s[j]);
                }
            }
            // 尾指针重复移动
            while (i <= j) {
                if (all.count(s[i]) == 0) {
                    i++;
                }
                else if (all.count(s[i]) > 0 && all[s[i]] < reserve[s[i]]) {
                    reserve[s[i]]--;
                    i++;
                }
                else {
                    break;
                }
            }
            // 最终判断
            if (remain.size() == 0) {
                // 无剩余
                if (minLen > j - i + 1) {
                    minLen = j - i + 1;
                    res = s.substr(i, minLen);
                }

                remain[s[i]] += 1;
                reserve[s[i]] -= 1;
                if (reserve[s[i]] <= 0) {
                    reserve.erase(s[i]);
                }
                i++;
            }
        }
        return res;
    }
};
```
### 结果
<img width="825" height="676" alt="image" src="https://github.com/user-attachments/assets/014a0781-f86e-4f4a-9388-b8c656ad3161" />


### 分析

时间复杂度O(n)，空间复杂度O(t)，n为字符长度，t为子字符串长度

### 优化

尝试减少一个哈希表

### 二次提交


### 结果

### 分析

