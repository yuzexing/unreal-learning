# 240. 搜索二维矩阵 II

### 初次提交
```
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        // 算法思想
        // 先按行遍历，找到比target小的最大值
        // 从该最大值所在列索引开始向下/向后遍历，直到找到目标值
        // 难点是怎么确定搜索的终止条件
        // 先来一个O(n)的算法
        int targetIndex = matrix[0].size();
        for (int i = 0; i < matrix[0].size(); i ++) {
            if (matrix[0][i] > target) {
                targetIndex = i;
                break;
            } else if (matrix[0][i] == target) {
                return true;
            }
        }
        targetIndex -= 1;
        for (int i = targetIndex; i >= 0; i --) {
            for (int j = 0; j < matrix.size(); j ++) {
                if (matrix[j][i] > target) {
                    break;
                } else if (matrix[j][i] == target) {
                    return true;
                }
            }
        }
        return false;
    }
};
```
### 结果
![image](https://github.com/user-attachments/assets/88604ac5-5843-45f9-8a78-7b726523f2a9)

### 分析
时间复杂度O(n), 空间复杂度O(1)
