# 事件委托

### 事件委托是否需要手动解绑

> 做一个实验，检测``InvocationList``中的DelegateInstance是否会被自动回收

不必须手动解绑，在每一次``AddDelegateInstance``时，会进行委托列表的收缩，删除其中引用为0的委托，也就是说，会自动解绑，不会导致委托列表过长

```
template <typename NewDelegateType>
	inline FDelegateHandle AddDelegateInstance(NewDelegateType&& NewDelegateBaseRef)
	{
		FWriteAccessScope WriteScope = GetWriteAccessScope();

		FDelegateHandle Result;
		if (NewDelegateBaseRef.IsBound())
		{
			// compact but obey threshold of when this will trigger
			CompactInvocationList(true);
			Result = NewDelegateBaseRef.GetHandle();
			InvocationList.Emplace(Forward<NewDelegateType>(NewDelegateBaseRef));
		}
		return Result;
	}
```

```
int32 OldNumItems = InvocationList.Num();

		// Find anything null or compactable and remove it
		for (int32 InvocationListIndex = 0; InvocationListIndex < InvocationList.Num();)
		{
			auto& DelegateBaseRef = InvocationList[InvocationListIndex];

			IDelegateInstance* DelegateInstance = DelegateBaseRef.GetDelegateInstanceProtected();
			if (DelegateInstance == nullptr	|| DelegateInstance->IsCompactable())
			{
				InvocationList.RemoveAtSwap(InvocationListIndex, EAllowShrinking::No);
			}
			else
			{
				InvocationListIndex++;
			}
		}
```

```
bool IsCompactable() const final
	{
#if UE_WITH_REMOTE_OBJECT_HANDLE
		return !UserObject.IsValid(true);
#else
		return !UserObject.Get(true);
#endif
	}

	bool IsSafeToExecute() const final
	{
		return !!UserObject.Get();
	}
```

#结论#:当指向``IDelegateInstance``的引用为0时，则该委托实例被删除


### 带返回值的事件委托

lyra中：
```
DECLARE_DELEGATE_RetVal(TSubclassOf<ULyraCameraMode>, FLyraCameraModeDelegate);
```

可以定义一个带返回值的事件委托，这里的返回值必须是TSubclassOf<ULyraCameraMode>

通过
```
// Delegate used to query for the best camera mode.
	FLyraCameraModeDelegate DetermineCameraModeDelegate;

const TSubclassOf<ULyraCameraMode> CameraMode = DetermineCameraModeDelegate.Execute();
```
获取到返回值CameraMode

### 委托的多种使用方式

1. 通知监听者，事件的执行，传递必要的参数
   条件：可以是多播，也可以是单播
2. 通过监听者获取其当前信息(带return的委托)
   条件：必须是单播

