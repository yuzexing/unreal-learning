# 事件委托

### 事件委托是否需要手动解绑

> 做一个实验，检测``InvocationList``中的DelegateInstance是否会被自动回收

不必须手动解绑，在每一次``AddDelegateInstance``时，会进行委托列表的收缩，删除其中引用为0的委托，也就是说，会自动解绑，不会导致委托列表过长

```
template <typename NewDelegateType>
	inline FDelegateHandle AddDelegateInstance(NewDelegateType&& NewDelegateBaseRef)
	{
		FWriteAccessScope WriteScope = GetWriteAccessScope();

		FDelegateHandle Result;
		if (NewDelegateBaseRef.IsBound())
		{
			// compact but obey threshold of when this will trigger
			CompactInvocationList(true);
			Result = NewDelegateBaseRef.GetHandle();
			InvocationList.Emplace(Forward<NewDelegateType>(NewDelegateBaseRef));
		}
		return Result;
	}
```

```
int32 OldNumItems = InvocationList.Num();

		// Find anything null or compactable and remove it
		for (int32 InvocationListIndex = 0; InvocationListIndex < InvocationList.Num();)
		{
			auto& DelegateBaseRef = InvocationList[InvocationListIndex];

			IDelegateInstance* DelegateInstance = DelegateBaseRef.GetDelegateInstanceProtected();
			if (DelegateInstance == nullptr	|| DelegateInstance->IsCompactable())
			{
				InvocationList.RemoveAtSwap(InvocationListIndex, EAllowShrinking::No);
			}
			else
			{
				InvocationListIndex++;
			}
		}
```

```
bool IsCompactable() const final
	{
#if UE_WITH_REMOTE_OBJECT_HANDLE
		return !UserObject.IsValid(true);
#else
		return !UserObject.Get(true);
#endif
	}

	bool IsSafeToExecute() const final
	{
		return !!UserObject.Get();
	}
```

当指向``IDelegateInstance``的引用为0时，则该委托实例被删除
