# 寻路算法

常见寻路算法：
1. 广度优先算法
2. Dijkstra算法
3. A*算法
4. 贪心算法
5. 流场算法
6. 人工势场
7. B*算法
9. JPS算法

### 广度优先算法


时间复杂度O(n+e)，空间复杂度O(n)，n表示节点数，e表示边数量

在寻路中需要记录路径，可以通过记录每个节点的父节点实现

可用于无权图求单源最短路径，得出的解必定是最短距离


### Dijkstra算法

用于**非负带权图**求单源最短路径，得出的解必定是最短距离

包含贪心算法的思想

算法思想：
1. 维护一个未确定最小距离的节点数组u，起始节点的距离置为0，其余节点置为无穷大
2. 维护一个当前最小距离表t：{ 距离，节点id }
3. 每一次从t中获取最小距离的节点m，将其置为已确定最小距离的节点
4. 获取m的邻居节点，更新最小距离表t
5. 重复3,4过程，直到目标节点被确定为已知最小距离的节点，或者所有节点都被确定

### A*算法

维护的数据结构：
1. 开放列表-待选点的优先级队列（可通过小根堆实现）
2. 闭合列表-确定点的集合
3. 父节点的映射集合（记录当前节点的父节点，用于回溯）

核心：评估函数f(n) = 当前位置距离起点的实际代价g(n) + 当前位置距离终点的估计代价h(n) = 综合优先级

算法思想：BFS算法改进，每次对代价估值较小的节点进行路径探索，直到找到节点或者所有节点都被遍历

实现步骤：
1. 初始化数据结构，起始点加入开放列表
2. 从开放列表中取综合优先级最小的节点，判断是否是终点
3. 如果是终点，则递归的获取父节点，直到起点，获得起点到终点的路线
4. 如果不是终点，则向四方向进行探索，选取该节点周围**未探索的节点**进行优先级计算，加入开放列表中
5. 重复上述过程，直到开放列表为空或者找到终点


得出的解不一定是最短距离，如果要保证最短距离，需要的条件：
- 估值代价严格小于或等于实际代价

公式：``f(n) = g(n) + h(n)``，``g(n)``为起点至该点的实际代价,``h(n)``为该点至终点的估值代价, ``f(n)``表示综合优先级


### JPS算法

JPS算法是A*算法的优化版本

思想：只将关键的跳跃点加入开放列表中，减少A*算法中开放列表中的节点数量，从而提高性能

#### 定义：强迫邻居

当节点A的8个邻居节点中存在障碍时，如果点A是点A父节点P，抵达点N的**必经节点**时，N是A的强迫邻居，即A存在强迫邻居N


#### 点A是跳跃点的条件
1. 点A是起点或者终点
2. 点A有强迫邻居
3. 点A的父节点在斜线方向搜索时，节点A的水平/垂直方向中存在满足条件1或2的点时


实现步骤：
1. 初始化与A*算法相似的数据结构
2. 从开放列表中选取评估值最小的点开始搜索
3. 水平、垂直方向搜索跳跃点
4. 斜线方向搜索跳跃点，每个斜线方向点搜索时，例如右上方搜索，对搜索点的右直线和上直线同时进行搜索(条件3)
5. 将跳跃点评估后加入开放列表，重复2-5，直到开放列表为空或者搜索到终点


> 其中需要考虑邻居裁剪和父节点列表的更新时机，待补充

