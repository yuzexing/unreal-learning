# C++链接过程


### 简述

链接是将各种代码和数据段收集、合并并组合成为一个单一的可执行文件的过程。链接器使得分离编译成为可能，允许我们独立的修改和编译单一模块，而不用重新编译整个源文件。

### 符号和符号表

对于可重定位的目标模块m，链接器关心的符号包括三种：
- 由模块m定义并且可以被其他模块引用的**全局符号**。全局链接符号对应于所有非静态的函数和全局变量。
- 由其他模块定义并且被模块m引用的**全局符号**。这些符号成为**外部符号**。
- 在模块m中定义和引用的**局部符号**。对应于被static修饰的函数和全局变量。这些符号在模块m中任何位置都可见，但是不能被其他模块引用。

> .symtab中不包含任何局部的非静态变量的符号，这些符号在运行时由栈管理。

#### 问题：在栈管理之前，这些局部的非静态变量存在哪里呢？

> 局部变量由栈管理，局部变量的初始值，大部分来自于.rodata中；已知的int值可以作为立即数写在指令里，其他例如浮点数、字符串是来自于.rodata中的。（待验证）


### 静态库中的符号解析的过程

- 符号解析阶段，链接器按命令行中的顺序扫描可重定位目标文件和存档文件
- 扫描过程中，链接器维护可重定位目标文件的集合E(这个集合中的文件会被合并行程可执行文件)
- 一个未解析符号集合U(引用但未定义)
- 已定义的符号集合D
- 初始UED均为空

1. 依次判断输入文件f是可重定位目标文件还是存档文件。如果是目标文件，则添加到E，更新U和D。然后继续扫描下一个文件
2. 如果输入文件f是存档文件。链接器对比U与存档文件成员定义的符号，如果某个成员匹m配，则将其加入E，更新U和D。没有匹配的存档成员则被丢弃。
3. 扫描结束后，如果U不为空，则报错。为空，则合并所有E并且进行重定位，构建可执行文件。


### 重定位

重定位由两步组成：
- **重定位节和符号定义**。首先链接器合并所有相同类型的节，形成新的聚合节。然后链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，赋给输入模块定义的每个符号。这一步完成时，程序中的每条指令和全局变量都有了唯一的运行时内存地址。（我的理解：此时符号表中的value全部已知且都是运行时的虚拟地址）
- **重定位节中的符号引用**。通过重定向表，链接器修改代码节和数据节中每个符号的引用，使得他们指向运行时的地址。



重定位的关键在于根据编译过程中由汇编器输出的重定位表(.rel.text和.rel.data)与符号表。重定位类型约32种，主要了解了两种：相对PC地址重定位。绝对地址重定位。
- 汇编器在遇到任何最终位置不确定的目标引用，都会生成重定位表项。
- 重定位表项关联了引用位置和符号，符号表关联了符号和定义位置。
- 在链接器符号解析阶段，将所有未定义符号的位置都解析为已知位置（value+section）。
- 最终：在重定位过程中，先合并，然后计算运行时地址，更新符号表，最后根据重定位表关联引用和定义


### 动态链接

动态链接发生在运行时，在启动可执行文件时加载动态库。

> 待补充动态链接 优先级五

### 动态链接和静态链接的对比

静态链接允许编译器和链接器进行更多的优化，（编译器可能需要开启全局优化才行），因为静态链接时，编译器和链接器可以看到更多的信息，而动态链接优化空间相较而言更少一些。


> 待补充细节
