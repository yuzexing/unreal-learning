# C++多态

### 定义

对于同一个接口，调用不同的实现。包括编译时多态和运行时多态：

1. 编译时多态：函数重载，运算符重载，模板
2. 运行时多态：虚函数

### 虚函数

虚函数是 C++ 中实现运行时多态的核心机制，通过在父类使用``virtual``关键字修饰成员函数，称为虚函数。一旦类中存在虚函数，编译器会为该类创建虚函数表，实现运行时的函数查询。

### 继承

子类构造时，会依次调用所有父类的构造函数，从顶层父类向下依次调用。

在成员初始化列表中，也可以显示调用父类构造函数。

### 问题一：为什么要从上至下依次调用构造函数？

> 存在子类对父类初始化数据的依赖，保证子类数据使用父类数据前的可靠性


### 虚析构函数

在继承的情况下，析构函数的顺序与构造函数的顺序相反。

虚析构函数表示，在多态时，可能存在被子类覆盖的析构函数，子类析构需要被先调用。

例子：
```
#include <iostream>
#include <vector>

class A {
public:
	A() {
		std::cout << "A construct" << std::endl;
	}
	virtual ~A() {
		std::cout << "A destruct" << std::endl;
	}
};

class B: public A {
public:
	B() {
		std::cout << "B construct" << std::endl;
	}
	~B() {
		std::cout << "B destruct" << std::endl;
	}
};

int main() {
	A* a = new B();
	delete a;
	std::cin.get();
    // A construct
    // B construct
    // B destruct
    // A destruct
}
```

析构函数常常是虚函数，如果不是虚函数，则``在多态下``只会调用父类的析构函数，无法调用子类析构函数。

#### 实例代码：
```
class A {
public:
	A() {
		cout << "A con" << endl;
	}
	A(int a) {
	}
	/*virtual */~A() {
		cout << "A des" << endl;
	}
};
class B : public A {
public:
	B() {
		cout << "B con" << endl;
	}
	~B() {
		cout << "B des" << endl;
	}	
};
int main() {
	A* b = new B();
	delete b;
	// only A des
	// no B des
}
```


### 虚函数表

作为多态在C++中的实现方式，允许父类指针指向子类实例时，调用子类中重写父类的方法。

具体实现方式时，在类中存在虚函数时，编译器会该对象的内存布局中插入一个隐藏的虚表指针vptr

插入时机是在构造函数前，地址指向虚函数表。

在继承的情况下，由于构造函数的顺序执行，会不断的更新虚表指针，直到最派生类(子类)的构造函数执行时，将虚表指针指向该最派生类对应的虚函数表。

特别的，在析构函数中，也会更新虚表指针(指向当前类的虚表)，避免在析构函数中执行已被析构的子类中的虚函数。

[stackoverflow](https://stackoverflow.com/questions/6591859/when-does-the-vptr-pointing-to-vtable-get-initialized-for-a-polymorphic-class)

虚函数表是一个函数指针数组

### 问题一：每一个类是否只有一个虚函数表？虚表指针是否可以继承？

> 最多一个虚函数表，虚表指针不可继承

### 问题二：虚函数表存在哪里？

> 一般在.rodata只读存储区中

### 问题三：编译器如何生成虚函数表？

> 只要基类有虚函数，则生成虚函数表

### 问题四：构造函数是否可以是虚函数？

> 不可以。因为调用构造函数前，还没有创建虚函数指针，而虚函数需要通过虚函数指针找到虚函数表才能调用。
> 报错提示：``'inline' is the only legal storage class for constructors``

### 问题五：构造函数中是否可以调用虚函数？

> 可以调用，但是不推荐调用虚函数，可能会存在未定义行为。\
> 首先是因为构造函数调用后是从父类开始初始化，按继承顺序进行子类初始化 \
> 如果在构造函数中调用虚函数，则会执行``当前类``中的虚函数实现 \
> 因为子类的虚函数指针在他的构造函数前初始化，当前构造函数中，只初始化了该类的虚函数指针 \
> 未定义行为：当在子类构造完毕时，成员变量初始化完成、虚函数指针初始化完成，在多态时就可以正确调用其子类实现 \
> 构造函数则无法正确调用其子类实现

### 虚函数表的性能分析

1. 空间：虚函数表以及虚函数指针的内存占用
2. 时间：
 1. 额外2次的访存指令：访问虚函数指针，访问虚函数表
 2. 干扰指令流水线的预测
 3. 多态函数的调用难以内联优化


### RTTI

只有存在虚函数的类才会创建RTTI，用于运行时的类型判断，(也可以在编译器中禁用生成RTTI)

其中存储了自身类型信息，父类信息等

RTTI存储在.rodata中，一般可以通过虚函数表访问

