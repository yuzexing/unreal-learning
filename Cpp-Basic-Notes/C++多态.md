# C++多态

### 虚函数

虚函数是 C++ 中实现运行时多态的核心机制，通过在父类使用``virtual``关键字修饰成员函数，称为虚函数。一旦类中存在虚函数，编译器会为该类创建虚函数表，实现运行时的函数查询。

### 继承

子类构造时，会依次调用所有父类的构造函数，从顶层父类向下依次调用。

在成员初始化列表中，也可以显示调用父类构造函数。

### 问题一：为什么要从上至下依次调用构造函数？

> 存在子类对父类初始化数据的依赖，保证子类数据使用父类数据前的可靠性


### 虚析构函数

在继承的情况下，析构函数的顺序与构造函数的顺序相反。

虚析构函数表示，在多态时，可能存在被子类覆盖的析构函数，子类析构需要被先调用。

例子：
```
#include <iostream>
#include <vector>

class A {
public:
	A() {
		std::cout << "A construct" << std::endl;
	}
	virtual ~A() {
		std::cout << "A destruct" << std::endl;
	}
};

class B: public A {
public:
	B() {
		std::cout << "B construct" << std::endl;
	}
	~B() {
		std::cout << "B destruct" << std::endl;
	}
};

int main() {
	A* a = new B();
	delete a;
	std::cin.get();
    // A construct
    // B construct
    // B destruct
    // A destruct
}
```

析构函数常常是虚函数，如果不是虚函数，则只会调用父类的析构函数，无法调用子类析构函数。


### 虚函数表

作为多态在C++中的实现方式，允许父类指针指向子类实例时，调用子类中重写父类的方法。

具体实现方式时，在类中存在虚函数时，编译器会该对象的内存布局中插入一个隐藏的虚表指针vptr

插入时机是在构造函数前，地址指向虚函数表。

在继承的情况下，由于构造函数的顺序执行，会不断的更新虚表指针，直到最派生类(子类)的构造函数执行时，将虚表指针指向该最派生类对应的虚函数表。

[stackoverflow](https://stackoverflow.com/questions/6591859/when-does-the-vptr-pointing-to-vtable-get-initialized-for-a-polymorphic-class)

虚函数表是一个函数指针数组

### 问题一：每一个类是否只有一个虚函数表？虚表指针是否可以继承？

> 最多一个虚函数表，虚表指针不可继承

### 问题二：虚函数表存在哪里？

> 一般在.rodata只读存储区中

### 问题三：编译器如何生成虚函数表？

> 只要基类有虚函数，则生成虚函数表

### 问题四：构造函数是否可以是虚函数？

> 不可以。因为调用构造函数前，还没有创建虚函数指针，而虚函数需要通过虚函数指针找到虚函数表才能调用。
> 报错提示：``'inline' is the only legal storage class for constructors``

### 虚函数表的性能分析

1. 空间：虚函数表以及虚函数指针的内存占用
2. 时间：
 1. 额外2次的访存指令：访问虚函数指针，访问虚函数表
 2. 干扰指令流水线的预测
 3. 多态函数的调用难以内联优化


### RTTI

只有存在虚函数的类才会创建RTTI，用于运行时的类型判断，(也可以在编译器中禁用生成RTTI)

其中存储了自身类型信息，父类信息等

RTTI存储在.rodata中，一般可以通过虚函数表访问

