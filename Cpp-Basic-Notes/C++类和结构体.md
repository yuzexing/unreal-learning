# C++类和结构体

### 类的作用
1. 维护一部分数据
2. 提供对内部数据的操作的方法


#### 类的理解
> 类使我们的代码可读性更高，使代码更简洁。但如果一个功能不使用类无法实现，那么使用类也无法实现，类的本质是语法糖。使复杂的事变的简单，而不是将不可能的事变为可能。

### 类的构造函数

1. 一般用于进行初始化操作，C++中需要显示的初始化所有基本数据类型。
2. 类有默认的构造函数。
3. 当不希望类被实例化时，可以通过隐藏构造函数达到该效果。
  - private consturct()
  - construct() = delete;

### 类的析构函数

1. 一般用于进行内存的回收操作
2. 虽然可以手动调用析构函数，但是不推荐这么做
```
定义
~construct() {
	// 释放内存
}
```

### 类的继承

C++中是多继承。

```
class A1 {};
class A2 {};
class A3 {};

class B : public A1, A2, private A3 {
	// C++中继承的写法
}
```
### 问题： ``B : public A``中所声明的public是什么意思？换成private会怎么样?

> 回答：C++中的继承分为公有继承、保护继承、私有继承，不同的继承方式会影响从父类继承成员的可见性。从父类继承的成员有``public``和``protected``的可见性的成员。换成``private``则将所有继承的成员可见性变为``private``。

### 私有继承、保护继承、公有继承的区别

属于C++可见性的范畴，可见性旨在与更好的组织代码，提高代码的可读性，可维护性。对于CPU无用。

先说明可见性的概念：

- **私有**成员仅对当前类可见。私有意味着是外部不需要关心的成员。
- **保护**可见性的成员对当前类及其子类可见。
- **共有**表示公开可见。外部也可以访问。
- 特殊情况：友元(friend)全部可见。

#### 补充
> - 上述的可见性逐步递增。
> - C++中继承时，仅继承**可见的成员**。
> - C++中可见性是对两个类之间的限定，同一个类中不存在可见性的限制。例如：
```
class A{
private:
	int m_a = 1;
public:
	A(const A& a) {
		m_a = a.m_a; // 在类A中访问A的实例中私有变量无限制
	}
};
```

### 继承时可见性标识符的作用：
1. 调整子类从父类继承的成员的可见性，可见性只保持或减小，不会扩大。
2. 声明继承关系的可见性。例如继承可见性声明为``private``，则外部不知道某两个类见存在继承关系，影响外部多态的使用。

例子：
```
class A {
public:
	int a;
};
class B : protected A {
public:
	B() {
		a; // B类中a的可见性为protected
	}
};
class C : private B {
public:
	C() {
		a; // C类中a的可见性为private
		A* b = new B(); // 编译通过
	}
private:
	void func() {
	}
};
A* b = new B(); // E0269 error
```

> 第一次见到私有继承的概念，C++里才有真正的"私生子"。

### 继承的作用
1. 减少重复代码，提高可维护性
2. 通过多态提高可扩展性

### 多继承的常见问题
1. 菱形继承
2. 命名冲突

### 菱形继承的问题

1. 数据冗余
2. 二义性

解决方法：虚继承
原理：
> 待补充原理

暂时将虚继承作为解决菱形继承的一种方式去理解

### 多继承下，如何通过对象偏移量找到对应的成员变量

> 子类将每个基类保存在不同的内存布局中，在多态情况下调整指针至对应的基类首地址

> 所以在多继承下，会保存每个基类的虚表指针，单继承则不会

> 补充多虚继承的情况


### 虚函数

允许多态下调用子类中重写的方法。代价：1.虚表(空间)，2.查表(时间)。

样例：
```
class A {
public:
	virtual void func() {
		std::cout << 'A' << std::endl;
	}
};
class B : private A {
public:
	void func() overide { // override还必须写在这里
		std::cout << 'B' << std::endl;
	}
};
A b = new B();
b.func(); // virtual修饰为打印B，无virtual修饰则打印A
```

#### 虚函数的底层实现

[虚函数实现](https://github.com/yuzexing/unreal-learning/blob/main/Cpp-Basic-Notes/C%2B%2B%E5%A4%9A%E6%80%81.md#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8)

### 纯虚函数
```
class A {
public:
	virtual void func() = 0;
}
```
> 当类中定义了纯虚函数时，该类无法进行实例化。
> 当类继承的函数中有纯虚函数，该类无法进行实例化，除非对该纯虚函数进行重写。
> 等价于java中的抽象函数。

### 类的本质

> 代码编写时面向开发者的抽象概念
> 实际上可以看做一段对数据的封装

### 类的成员

[成员和嵌套成员的介绍](https://www.learncpp.com/cpp-tutorial/nested-types-member-types/)

### 类和结构体的区别

1. 从技术上来说，class和struct在默认的可见性上有区别，class默认是private，struct默认是public
2. 从抽象层面上说，class和struct的使用取决于编程风格和习惯：
  - 一般简单的数据集合，常使用结构体维护。
  - 较为复杂的情况，例如需要继承（结构体也可以继承）的情况，常使用类进行维护。

### 问题一：类和结构体存储在哪个区域？

> 类和结构体在程序运行时主要是以"构造函数"的形式存放在.text中，用于进行初始化操作，其余的成员函数也均在.text中存放，静态成员存放在静态存储区。
> 当新建一个类实例时：
> 1. 分配对象所需空间（栈或者堆中）
> 2. 将该空间首地址传入构造函数，从头开始初始化非静态的成员变量
> 3. 当执行类成员函数时，传入对象的首地址(this指针)，进行统一的数据操作

> 类是在编程时对程序员可见的抽象概念，在编译后被解构为一个个数据和函数

### 问题二：这段代码为什么会链接错误？
```
class A {
public:
	static int a;
};

int main() {
	A::a = 1;
	return 0;
}
//main.obj : error LNK2001: unresolved external symbol "public: static int A::a" (?a@A@@2HA)
```

### 问题三：为什么类中非常量的静态成员不允许初始化？
```
class A {
public:
	static int a = 1; // 编译报错
};
// E1592, 必须声明常量才能初始化
```

> 回答：静态成员在类定义中只能作声明，而(不能定义)[https://en.cppreference.com/w/cpp/language/static]。
> 但是为什么呢？[https://stackoverflow.com/questions/45277976/why-can-static-member-function-definitions-not-have-the-keyword-static]

我的理解：
1. 静态成员的初始化与类实例的初始化无关，所以不能在类定义中进行初始化(除非编译器做代码优化，替我们补全外部定义)
2. 类中的非静态成员变量初始化是在类实例化的时候，而类静态成员存储在静态存储区，具有静态存储周期

> 由const修饰的整型和枚举类型的静态成员，可以在类定义中初始化，也可以在类外初始化
> C++17 声明inline的静态成员变量**只能**在类定义中定义。（为什么inline有这样的功能?待补充）
> C++11的constexpr修饰的静态成员变量**只能**在类定义中定义，这种可能会作为编译时常量进行优化。


[static](https://en.cppreference.com/w/cpp/language/static)

### 函数中的字面量存在哪个区？

> 字面量是代码中给出的固定值，例如数值字面量:42，1.0f，字符字面量：'c'，字符串字面量："abc"
> 函数中的字面量大部分在常量区，也就是字面量存储在常量区，但是也存在将数据作为立即数编码在指令中的情况
> 还需要补充"字面量池"
> 对于全局或者静态的字面量，可以在.data或者.bss的静态区存储

### 结构体存在的意义
1. 兼容C语言










