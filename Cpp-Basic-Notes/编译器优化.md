# 编译器优化

编译器的优化

### 常量折叠

将常量表达式，直接计算结果，减少运行时开销
```
int x = 2 + 3;   // 直接变成 int x = 5;
```

### 常量传播

将常量变量替换为常量值，
```
const int N = 100;
int arr[N];     // 将 N 替换为 100
```

### 死代码消除

死代码分为：``不可达代码``和``无用定义代码``

1. 不可达代码代码从程序入口进行分析，判断不可达的代码
2. 无用定义代码从``必要指令``进行分析，递归的对必要指令有贡献的指令设置为``必要指令``

总结
1. 从入口出发分析
2. 从结果出发分析

### 公共子表达式消除

提取同一表达式的重复计算结果

> 由编译器计算的成本效益分析可以判断出，重复计算该表达式的开销是否大于存储该表达式的计算结果，并且这个分析也要将寄存器等因素考虑在内。

```
int a = x*y + z;
int b = x*y + w;  // x*y 只计算一次
```

### 指令重排序和内存屏障

### 为什么要指令重排序
