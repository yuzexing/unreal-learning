# 编译器优化

编译器的优化

### 常量折叠

将常量表达式，直接计算结果，减少运行时开销
```
int x = 2 + 3;   // 直接变成 int x = 5;
```

### 常量传播

将常量变量替换为常量值，
```
const int N = 100;
int arr[N];     // 将 N 替换为 100
```

### 复制传播

将简单赋值中的变量直接替换，减少中间变量。
```
int a = b;
int c = a + 1;    // 变成 int c = b + 1;
```
### 死代码消除

死代码分为：``不可达代码``和``无用定义代码``

1. 不可达代码代码从程序入口进行分析，判断不可达的代码
2. 无用定义代码从``必要指令``进行分析，递归的对必要指令有贡献的指令设置为``必要指令``

总结
1. 从入口出发分析
2. 从结果出发分析

> 无条件的

### 公共子表达式消除

提取同一表达式的重复计算结果

> 由编译器计算的成本效益分析可以判断出，重复计算该表达式的开销是否大于存储该表达式的计算结果，并且这个分析也要将寄存器等因素考虑在内。

```
int a = x*y + z;
int b = x*y + w;  // x*y 只计算一次
```

### 分支折叠和分支预测

1. 分支折叠删除恒为真或假的分支
2. 分支预测

分支预测还可以通过程序员的提示``__builtin_expect``、``[[likely]]/[[unlikely]]``代码给编译器提示

分支预测会对流水线冒险中的分支冒险有作用，可以减少流水线气泡或者错误取指的情况

控制冒险(分支冒险)：遇到分支时，由于要等到分支条件计算完才能确定下一条要取的指令，流水线会出现气泡（stall）或错误取指

流水线冒险分为：结构冒险(冲突)，数据冒险(冲突)，控制冒险(冲突)。

### 指令重排序和内存屏障

### 为什么要指令重排序
