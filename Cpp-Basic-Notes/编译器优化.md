# 编译器优化

编译器的优化

### 常量折叠

将常量表达式，直接计算结果，减少运行时开销
```
int x = 2 + 3;   // 直接变成 int x = 5;
```


### 常量传播

将常量变量替换为常量值，
```
const int N = 100;
int arr[N];     // 将 N 替换为 100
```

### 复制传播

将简单赋值中的变量直接替换，减少中间变量。
```
int a = b;
int c = a + 1;    // 变成 int c = b + 1;
```
### 死代码消除

死代码分为：``不可达代码``和``无用定义代码``

1. 不可达代码代码从程序入口进行分析，判断不可达的代码
2. 无用定义代码从``必要指令``进行分析，递归的对必要指令有贡献的指令设置为``必要指令``

总结
1. 从入口出发分析
2. 从结果出发分析

> 无条件的

### 公共子表达式消除

提取同一表达式的重复计算结果

> 由编译器计算的成本效益分析可以判断出，重复计算该表达式的开销是否大于存储该表达式的计算结果，并且这个分析也要将寄存器等因素考虑在内。

```
int a = x*y + z;
int b = x*y + w;  // x*y 只计算一次
```

原理：构建DAG（有向无环图），合并相同节点

### 分支折叠和分支预测

1. 分支折叠删除恒为真或假的分支
2. 分支预测

分支预测还可以通过程序员的提示``__builtin_expect``、``[[likely]]/[[unlikely]]``代码给编译器提示

分支预测会对流水线冒险中的分支冒险有作用，可以减少流水线气泡或者错误取指的情况

控制冒险(分支冒险)：遇到分支时，由于要等到分支条件计算完才能确定下一条要取的指令，流水线会出现气泡（stall）或错误取指

流水线冒险分为：结构冒险(冲突)，数据冒险(冲突)，控制冒险(冲突)。

### 函数内联

根据编译器的成本收益分析，决定是否将函数内联

### 尾调用优化

对于函数尾部的函数调用语句(call)，不用保留当前栈帧的内容，所以可以不用新开一个栈帧，在当前栈帧上进行变量分配，使用``jump``指令代替``call``指令。

条件：
1. 函数在末尾调用
2. 开启尾调用优化(O2及以上)
3. C++中析构函数的影响，由于析构顺序改变了，所以如果存在对象需要析构，则可能无法应用尾调用优化

优势：
1. 减少栈的深度
2. 减少现场保存与返回的过程
3. ``jump``指令更高效

[zhihu](https://zhuanlan.zhihu.com/p/631384756)

### 尾递归消除

尾调用的特殊情况

对于尾递归，编译器可以将递归改为迭代的形式。(递归改非递归)

[wiki](https://oi-wiki.org/lang/optimizations/#%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96-tail-call-optimization)

### 循环展开

将循环代码展开为顺序执行

条件：
1. 循环次数已知
2. 编译器收益成本分析决定

优点：避免分支冒险
缺点：代码体积增加

### 循环不变量外提

将循环中不变量提到循环之外，减少循环中指令数量

### 指令重排序

含义：在不改变单线程语义的情况下，对指令进行重排序，避开数据相关和结构相关的流水线气泡


和内存屏障

### 为什么要指令重排序
